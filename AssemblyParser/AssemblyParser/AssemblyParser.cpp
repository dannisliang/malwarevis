// AssemblyParser.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <list>
#include <locale>
using namespace std;

struct Node{
	int id;
	string codeBlock;
	string startAddress;
	std::list<string> childAddress;
	std::list<string> parentAddress;
	std::list<int> childIDS;
	//string* childAddress;
	//string* parentAddress;
	string lastAddress; //address of jmp instruction
	string loopbackAddress;
	string childLoopback;
	int parentLoopback;
	Node()
	{
		id = -1;
		codeBlock = "";
		childAddress.clear();
		parentAddress.clear();
		lastAddress = "";

	}
} Block;

class Statement{
	public:
		std::string address;
		std::string opCode;
		std::string instruction;
		std::string name;
		std::string data;
		Statement()
		{
			address = "";
			opCode = "";
			instruction = "";
			name = "";
			data = "";

		}
		void display()
		{
			cout << address << "\t" << opCode << "\t" << instruction<<"\n"<<name<<"\n";
		}
};

string trim(const std::string& str, const std::string& whitespace = " \t")
{
	const auto strBegin = str.find_first_not_of(whitespace);
	if (strBegin == std::string::npos)
		return ""; // no content

	const auto strEnd = str.find_last_not_of(whitespace);
	const auto strRange = strEnd - strBegin + 1;

	return str.substr(strBegin, strRange);
}
void ParseLine(string line, Statement* statement)
{
	int index = -1;// will refer to the index of end of the address
	int index2 = -1;// will refer to the index of beginning of the opcode
	int index3 = -1; // will refer to the index of end of the opcode
	int index4 = -1; // will refer to the index of beginning of the instruction

	if (line[0] == '\r')
	{
		line.replace(0, 1, "");
	}
	if (line.substr(0, 2) == "0x")
	{
		index = line.find_first_of(" ", 1);
		if (index != -1)
		{
			//parsing the address
			statement->address = trim(line.substr(0, index));

			for (int i = index; i < line.length(); i++)
			{
				if (line[i] == ' ')
				{
					continue;
				}
				else
				{
					index2 = i;
					break;
				}
			}

			//Parsing the opcode
			index3 = line.find_first_of(" ", index2);

			if (index3 != -1)
			{
				statement->opCode = trim(line.substr(index2, index3 - index2));
				for (int i = index3; i < line.length(); i++)
				{
					if (line[i] != ' ')
					{
						continue;
					}
					else
					{
						index4 = i;
						break;
					}
				}
				//parsing the instruction
				statement->instruction = trim(line.substr(index4, line.length() - index4));
			}
			else
			{
				statement->name = trim(line.substr(index2, line.length()));
			}

			//statement.display();
			//getchar();

		}
	}

}
std::string ToUpper(const std::string& s)
{
	std::string result;
	std::locale loc;
	for (unsigned int i = 0; i < s.length(); ++i)
	{
		result += std::toupper(s.at(i), loc);
	}

	return result;
}
std::string toLower(const std::string& s)
{
	std::string result;
	std::locale loc;
	for (unsigned int i = 0; i < s.length(); ++i)
	{
		result += std::tolower(s.at(i), loc);
	}

	return result;
}
std::string ParseCommand(string instruction){
	return(instruction.substr(0, instruction.find_first_of(" ", 1)));
}
bool CheckForJumpCommand(string instruction)
{
	string jumpInstructions[] = { "JA", "JAE", "JB", "JBE", "JC", "JCXZ", "JECXZ", "JRCXZ", "JE", "JG", "JGE", "JL", "JLE", "JNA", "JNAE", "JNB", "JNBE", "JNC"
		, "JNE", "JNG", "JNGE", "JNL", "JNLE", "JNO", "JNP", "JNS", "JNZ", "JO", "JP", "JPE", "JPO", "JS", "JZ", "JMP" };
	std::list<string> jumpAddresses;
	string command = ParseCommand(instruction);
	for (int ind = 0; ind < (sizeof(jumpInstructions) / sizeof(*jumpInstructions)); ind++)
	{

		if (toLower(jumpInstructions[ind]) == toLower(command)){
			return true;
			break;
		}
	}
	return false;
}
bool ValidateAddress(string address)
{
	address = trim(address);
	if (address.find_first_of("0x")==0)
	{
		return true;
	}
	else
	{
		return false;
	}
}
unsigned int ConvertHexToInt(string hex)
{
	//unsigned int hexnum;
	//std::stringstream ss;
	//ss << std::hex << hex;
	//ss >> hexnum;

	//return hexnum;

	std::string str = hex;
	const char *cstr = str.c_str();
	unsigned long hex_value = std::strtoul(cstr, 0, 16);
	//delete[] cstr;
	return hex_value;
}
string ConvertToString(int number)
{
	string result;          // string which will contain the result

	ostringstream convert;   // stream used for the conversion

	convert << number;      // insert the textual representation of 'Number' in the characters in the stream

	result = convert.str();
	return result;
}


std::list<Statement> ParseStateMents(string fullFilePath)
{
	string line;
	std::list<Statement> statements;
	ifstream myfile(fullFilePath);
	Statement statement;
	if (myfile.is_open())
	{
		while (getline(myfile, line))
		{
			statement = Statement();
			ParseLine(line, &statement);
			//statement.display();
			statements.push_back(statement);
		}
		//getchar();
		myfile.close();
	}
	else
	{
		cout << "Unable to open file";
	}

	return statements;
}

void HandleSwitchStatement()
{

}
void FillNodeData(std::list<Node> nodes)
{
	for (std::list<Node>::iterator n = nodes.end(); n != nodes.begin(); --n)
	{
		//cout<<*it<<"\n";
		cout << n->lastAddress << "\n";
	}
}


std::list<string> CreateListOfJumpAddresses(std::list<Statement> statements)
{
	std::list<string> jumpAddresses;
	string jumpInstructions[] = { "JA", "JAE", "JB", "JBE", "JC", "JCXZ", "JECXZ", "JRCXZ", "JE", "JG", "JGE", "JL", "JLE", "JNA", "JNAE", "JNB", "JNBE", "JNC"
		, "JNE", "JNG", "JNGE", "JNL", "JNLE", "JNO", "JNP", "JNS", "JNZ", "JO", "JP", "JPE", "JPO", "JS", "JZ", "JMP" };
	string command = "";
	string instruction = "";
	string jmpaddress;
	string address;

	for (std::list<Statement>::iterator it = statements.begin(); it != statements.end(); ++it)
	{
		instruction = it->instruction;
		if (instruction != ""){

			command = instruction.substr(0, instruction.find_first_of(" ", 1));
			for (int ind = 0; ind < (sizeof(jumpInstructions) / sizeof(*jumpInstructions)); ind++)
			{

				if (toLower(jumpInstructions[ind]) == toLower(command)){
					bool checkElementDuplicacy = false;
					jmpaddress = trim(instruction.substr(instruction.find_first_of(" ", 1), instruction.length()));
					if (ValidateAddress(jmpaddress)){

						for (std::list<string>::iterator jmpListIterator = jumpAddresses.begin(); jmpListIterator != jumpAddresses.end(); ++jmpListIterator)
						{
							if (*jmpListIterator == jmpaddress)
							{
								checkElementDuplicacy = true;
								break;
							}
						}
						if (!checkElementDuplicacy)
						{
							jumpAddresses.push_back(jmpaddress);
						}

					}
					else{
						//Might be because of jump table
					}
					break;
				}
			}

		}

	}
	return jumpAddresses;
}

bool SearchForAddress(string statement, string address)
{
	int indexOfComment = statement.find_first_of(";", 0);
	int indexOfAddress = statement.find(address);
	if ((indexOfComment == -1 && indexOfAddress!=-1) || indexOfComment>indexOfAddress)
	{
		return true;
	}
	return false;
}

std::string GetAddress(string statement)
{
	int indexOfComment = statement.find_first_of(";", 0);
	int indexOfAddressBegin = statement.find("0x", 0);
	string address = "";
	if (indexOfAddressBegin!=-1 && (indexOfComment == -1 || indexOfComment > indexOfAddressBegin)){
		int indexOfAddressEnd = statement.find(" ", indexOfAddressBegin);
		address=statement.substr(indexOfAddressBegin, indexOfAddressEnd - indexOfAddressBegin);
		return address;
	}
	return "";
}


void str_replace(string &s, const string &search, const string &replace)
{
	for (size_t pos = 0;; pos += replace.length())
	{
		pos = s.find(search, pos);
		if (pos == string::npos) break;

		s.erase(pos, search.length());
		s.insert(pos, replace);
	}
}

std::list<Node> GenerateCodeBlock(std::list<Node> nodes, string fullFilePathOfDetailedFile)
{
	std::list<string> lines; 
	string line;
	ifstream myfile(fullFilePathOfDetailedFile);
	Statement statement;
	string codeBlock = "";
	if (myfile.is_open())
	{
		while (getline(myfile, line))
		{
			if (line[0] == '\r')
			{
				line.replace(0, 1, "");
			}
			lines.push_back(line);
		}
		//getchar();
		myfile.close();
	}
	else
	{
		cout << "Unable to open file";
	}
	std::list<string>::iterator iterator=lines.begin();

	for (std::list<Node>::iterator st = nodes.begin(); st != nodes.end(); ++st)
	{
		for (std::list<string>::iterator it = iterator; it != lines.end(); ++it)
		{
			if (st->startAddress == "")
			{
				st->startAddress=GetAddress(*it);
			}
			
			codeBlock = codeBlock + "\n" + *it;
			if (SearchForAddress(*it, st->lastAddress))
			{
				
				st->codeBlock = codeBlock;
				iterator = it;
				//break;
			}
			
		}
		iterator++;
		cout << st->id << "\n";
		cout << st->codeBlock<<"\n";
		cout << st->startAddress << "\n";
		codeBlock = "";
	}
	return nodes;


}
void DumpObjectToXMLFILE(std::list<Node> nodes, list<string> commandsList, list<string> adressessList, list<string> operandsList, string outputFileFullPath)
{
	string xml = "";
	xml = xml + "<xml>\n";
	for (std::list<Node>::iterator st = nodes.begin(); st != nodes.end(); ++st){
		xml = xml + "\t<node>\n";
		xml = xml + "\t<id>" + ConvertToString(st->id) + "</id>\n";
		xml = xml + "\t<StartAddress>" + (st->startAddress) + "</StartAddress>\n";
		xml = xml + "\t<LastAddress>" + (st->lastAddress) + "</LastAddress>\n";
		//Add RTF Tags
		for (std::list<string>::iterator it = commandsList.begin(); it != commandsList.end(); ++it)
		{
			str_replace((st->codeBlock), *it, "<color=blue>" + *it + "</color>");
		}
		for (std::list<string>::iterator it = adressessList.begin(); it != adressessList.end(); ++it)
		{
			str_replace((st->codeBlock), *it, "<color=green>" + *it + "</color>");
		}
		for (std::list<string>::iterator it = operandsList.begin(); it != operandsList.end(); ++it)
		{
			str_replace((st->codeBlock), *it, "<color=yellow>" + *it + "</color>");
		}

		xml = xml + "\t<CodeBlock>"  + "<![CDATA["+(st->codeBlock)+"]]>" + "\n\t</CodeBlock>\n";
		xml = xml + "\t<ChildAddresses>\n";
		for (std::list<string>::iterator itChildAddress = st->childAddress.begin(); itChildAddress != st->childAddress.end(); ++itChildAddress){
			xml = xml + "\t\t<Address>" + (*itChildAddress) + "</Address>\n";
		}
		xml = xml + "\t</ChildAddresses>\n";
		xml = xml + "\t</node>\n";
	}
	xml = xml + "\t</xml>";


	std::ofstream out("output.xml");
	out << xml;
	out.close();
}
void DumpCodeToXMLFILEWithRTF(string fullFilePathOfDetailedFile, list<string> commandsList, list<string> adressessList, list<string> operandsList, string outputFileFullPath)
{
	std::string content;
	std::ifstream ifs(fullFilePathOfDetailedFile);
	content.assign((std::istreambuf_iterator<char>(ifs)),
		(std::istreambuf_iterator<char>()));
	ifs.close();
	for (std::list<string>::iterator it = commandsList.begin(); it != commandsList.end(); ++it)
	{
		str_replace(content, *it, "<color=blue>" + *it +"</color>");
	}
	for (std::list<string>::iterator it = adressessList.begin(); it != adressessList.end(); ++it)
	{
		str_replace(content, *it, "<color=green>" + *it + "</color>");
	}
	for (std::list<string>::iterator it = operandsList.begin(); it != operandsList.end(); ++it)
	{
		str_replace(content, *it, "<color=yellow>" + *it + "</color>");
	}
	//str_replace(content);
	std::ofstream out(outputFileFullPath);
	out << content;
	out.close();
}
int _tmain(int argc, _TCHAR* argv[])
{
	//cout << trim(" abcde ").length();
	Node node;
	string line;
	string codeBlock;
	std::list<string> lastBlockAddress;
	std::list<string> jumpAddresses;
	std::list<string> adressessList;
	std::list<string> operandsList;
	std::list<string> commandsList;
	std::list<Node> nodes;
	string jumpInstructions[] = { "JA", "JAE", "JB", "JBE", "JC", "JCXZ", "JECXZ", "JRCXZ", "JE", "JG", "JGE", "JL", "JLE", "JNA", "JNAE", "JNB", "JNBE", "JNC"
		, "JNE", "JNG", "JNGE", "JNL", "JNLE", "JNO", "JNP", "JNS", "JNZ", "JO", "JP", "JPE", "JPO", "JS", "JZ","JMP" };
	std::list<Statement> statements;
	std::list<int>::iterator linenumber;
	string fullFilePath = "C:\\Users\\Swastik\\Google Drive\\Research\\Malaware Visualization\\Tool\\radare2-w32-0.9.9-git\\test.txt";
	string fullFilePathOfDetailedFile = "C:\\Users\\Swastik\\Google Drive\\Research\\Malaware Visualization\\Tool\\radare2-w32-0.9.9-git\\test.txt";
	statements = ParseStateMents(fullFilePath);
	string command = "";
	string instruction = "";
	int id = 0;
	string jmpaddress;
	string address;
	int cnt = 0;

	jumpAddresses = CreateListOfJumpAddresses(statements);

	for (std::list<Statement>::iterator it = statements.begin(); it != statements.end(); ++it)
	{
		cnt++;
		instruction = it->instruction;
		if (instruction != ""){
			
			command = instruction.substr(0, instruction.find_first_of(" ", 1));
			commandsList.push_back(command);
			adressessList.push_back(it->address);
			if (instruction.find_first_of(" ", 1) < instruction.length())
			{
				operandsList.push_back((instruction.substr(instruction.find_first_of(" ", 1), instruction.length())));
			}
			
			bool isJump = false;
			for (int ind = 0; ind < (sizeof(jumpInstructions) / sizeof(*jumpInstructions)); ind++)
			{
				
				if (toLower(jumpInstructions[ind]) == toLower(command)){
					cout << command<<"\n";
					node=Node();
					node.id = id++;
					jmpaddress = trim(instruction.substr(instruction.find_first_of(" ", 1), instruction.length()));
					if (ValidateAddress(jmpaddress)){
						address = it->address;
						node.childAddress.push_back(jmpaddress);
						//cout << jmpaddress << "\n";
						++it;
						//adding next instructions address as a child's address
						node.childAddress.push_back(it->address);

						--it;
					}
					else{
						//Might be because of jump table
					}
					node.lastAddress = it->address;
					lastBlockAddress.push_back(it->address);
					nodes.push_back(node);
					isJump = true;
					break;
				}
				
			}
			if (isJump)
			{
				isJump = false;
				continue;

			}

			for (std::list<string>::iterator jmpListIterator = jumpAddresses.begin(); jmpListIterator != jumpAddresses.end(); ++jmpListIterator)
			{
				string test = *jmpListIterator;
				int statementAddress = ConvertHexToInt(it->address);
				int jmpAddress = ConvertHexToInt(*jmpListIterator);
				if (statementAddress == jmpAddress)
				{
					
					
					--it;
					instruction = it->instruction;
					command = instruction.substr(0, instruction.find_first_of(" ", 1));
					bool exists = (std::find(std::begin(jumpInstructions), std::end(jumpInstructions), ToUpper(command)) != std::end((jumpInstructions)));
					if (exists){
						++it;
						continue;
					}
					node = Node();
					node.id = id++;
					node.lastAddress = it->address;
					++it;
					node.childAddress.push_back(it->address);
					nodes.push_back(node);
					
					
					/*if (CheckForJumpCommand(it->instruction))
					{
						node.childAddress.push_back(it->address);
					}*/
					
				}
			}

			
		
		}
		//adding node at the end of the assembly code
		if (statements.size()==(cnt) )
		{
			node = nodes.back();
			
			if (node.lastAddress == "")
			{
				nodes.pop_back();
				node.lastAddress == it->address;
			}
			else
			{
				node = Node();
				node.id = id++;
				node.lastAddress = it->address;
				nodes.push_back(node);
			}
			//Node node;
			
			lastBlockAddress.push_back(it->address);
		}

		

		
	}
	
	std::list<Node>::iterator n = nodes.end();
	do{
		--n;
		cout <<n->id<<":"<< n->lastAddress << "\n";
	} while (n != nodes.begin());
	
	nodes = GenerateCodeBlock(nodes, fullFilePathOfDetailedFile);
	cout << nodes.size();
	commandsList.sort();
	commandsList.unique();
	adressessList.unique();
	adressessList.sort();
	operandsList.unique();
	operandsList.sort();

	

	DumpCodeToXMLFILEWithRTF(fullFilePathOfDetailedFile,commandsList,adressessList,operandsList,"outputRTF.txt");

	DumpObjectToXMLFILE(nodes, commandsList, adressessList, operandsList, "output.txt");
	return 0;
}

