//// AssemblyParser.cpp : Defines the entry point for the console application.
////
//
//#include "stdafx.h"
//#include <iostream>
//#include <fstream>
//#include <sstream>
//#include <string>
//#include <list>
//#include <locale>
//using namespace std;
//
//struct Node{
//	int id;
//	string codeBlock;
//	std::list<string> childAddress;
//	std::list<string> parentAddress;
//	//string* childAddress;
//	//string* parentAddress;
//	string lastAddress; //address of jmp instruction
//	string loopbackAddress;
//	string childLoopback;
//	int parentLoopback;
//	Node()
//	{
//		id = -1;
//		codeBlock = "";
//		childAddress.clear();
//		parentAddress.clear();
//		lastAddress = "";
//
//	}
//} Block;
//
//class Statement{
//public:
//	std::string address;
//	std::string opCode;
//	std::string instruction;
//	std::string name;
//	Statement()
//	{
//		address = "";
//		opCode = "";
//		instruction = "";
//		name = "";
//
//	}
//	void display()
//	{
//		cout << address << "\t" << opCode << "\t" << instruction << "\n" << name << "\n";
//	}
//};
//
//string trim(const std::string& str, const std::string& whitespace = " \t")
//{
//	const auto strBegin = str.find_first_not_of(whitespace);
//	if (strBegin == std::string::npos)
//		return ""; // no content
//
//	const auto strEnd = str.find_last_not_of(whitespace);
//	const auto strRange = strEnd - strBegin + 1;
//
//	return str.substr(strBegin, strRange);
//}
//void ParseLine(string line, Statement* statement)
//{
//	int index = -1;// will refer to the index of end of the address
//	int index2 = -1;// will refer to the index of beginning of the opcode
//	int index3 = -1; // will refer to the index of end of the opcode
//	int index4 = -1; // will refer to the index of beginning of the instruction
//
//	if (line[0] == '\r')
//	{
//		line.replace(0, 1, "");
//	}
//	if (line.substr(0, 2) == "0x")
//	{
//		index = line.find_first_of(" ", 1);
//		if (index != -1)
//		{
//			//parsing the address
//			statement->address = trim(line.substr(0, index));
//
//			for (int i = index; i < line.length(); i++)
//			{
//				if (line[i] == ' ')
//				{
//					continue;
//				}
//				else
//				{
//					index2 = i;
//					break;
//				}
//			}
//
//			//Parsing the opcode
//			index3 = line.find_first_of(" ", index2);
//
//			if (index3 != -1)
//			{
//				statement->opCode = trim(line.substr(index2, index3 - index2));
//				for (int i = index3; i < line.length(); i++)
//				{
//					if (line[i] != ' ')
//					{
//						continue;
//					}
//					else
//					{
//						index4 = i;
//						break;
//					}
//				}
//				//parsing the instruction
//				statement->instruction = trim(line.substr(index4, line.length() - index4));
//			}
//			else
//			{
//				statement->name = trim(line.substr(index2, line.length()));
//			}
//
//			//statement.display();
//			//getchar();
//
//		}
//	}
//
//}
//
//std::string toLower(const std::string& s)
//{
//	std::string result;
//	std::locale loc;
//	for (unsigned int i = 0; i < s.length(); ++i)
//	{
//		result += std::tolower(s.at(i), loc);
//	}
//
//	return result;
//}
//std::string ParseCommand(string instruction){
//	return(instruction.substr(0, instruction.find_first_of(" ", 1)));
//}
//bool CheckForJumpCommand(string instruction)
//{
//	string jumpInstructions[] = { "JA", "JAE", "JB", "JBE", "JC", "JCXZ", "JECXZ", "JRCXZ", "JE", "JG", "JGE", "JL", "JLE", "JNA", "JNAE", "JNB", "JNBE", "JNC"
//		, "JNE", "JNG", "JNGE", "JNL", "JNLE", "JNO", "JNP", "JNS", "JNZ", "JO", "JP", "JPE", "JPO", "JS", "JZ", "JMP" };
//	std::list<string> jumpAddresses;
//	string command = ParseCommand(instruction);
//	for (int ind = 0; ind < (sizeof(jumpInstructions) / sizeof(*jumpInstructions)); ind++)
//	{
//
//		if (toLower(jumpInstructions[ind]) == toLower(command)){
//			return true;
//			break;
//		}
//	}
//	return false;
//}
//bool ValidateAddress(string address)
//{
//	address = trim(address);
//	if (address.find_first_of("0x") == 0)
//	{
//		return true;
//	}
//	else
//	{
//		return false;
//	}
//}
//unsigned int ConvertHexToInt(string hex)
//{
//	unsigned int hexnum;
//	std::stringstream ss;
//	ss << std::hex << hex;
//	ss >> hexnum;
//
//	return hexnum;
//}
//void HandleSwitchStatement()
//{
//
//}
//void FillNodeData(std::list<Node> nodes)
//{
//	for (std::list<Node>::iterator n = nodes.end(); n != nodes.begin(); --n)
//	{
//		//cout<<*it<<"\n";
//		cout << n->lastAddress << "\n";
//	}
//}
//int _tmain(int argc, _TCHAR* argv[])
//{
//	//cout << trim(" abcde ").length();
//	Node node;
//	string line;
//	std::list<string> lastBlockAddress;
//	std::list<string> jumpAddresses;
//	std::list<Node> nodes;
//	string jumpInstructions[] = { "JA", "JAE", "JB", "JBE", "JC", "JCXZ", "JECXZ", "JRCXZ", "JE", "JG", "JGE", "JL", "JLE", "JNA", "JNAE", "JNB", "JNBE", "JNC"
//		, "JNE", "JNG", "JNGE", "JNL", "JNLE", "JNO", "JNP", "JNS", "JNZ", "JO", "JP", "JPE", "JPO", "JS", "JZ", "JMP" };
//	std::list<Statement> statements;
//	std::list<int>::iterator linenumber;
//	string fullFilePath = "C:\\Users\\Swastik\\Google Drive\\Research\\Malaware Visualization\\Tool\\radare2-w32-0.9.9-git\\test.txt";
//	ifstream myfile(fullFilePath);
//	Statement statement;
//	if (myfile.is_open())
//	{
//		while (getline(myfile, line))
//		{
//			statement = Statement();
//			ParseLine(line, &statement);
//			//statement.display();
//			statements.push_back(statement);
//		}
//		//getchar();
//		myfile.close();
//	}
//	else
//	{
//		cout << "Unable to open file";
//	}
//	string command = "";
//	string instruction = "";
//	int id = 0;
//	string jmpaddress;
//	string address;
//	//int iaddress;
//	int cnt = 0;
//	for (std::list<Statement>::iterator it = statements.begin(); it != statements.end(); ++it)
//	{
//		cnt++;
//		instruction = it->instruction;
//		if (instruction != ""){
//
//			//it->address<<"\n";
//			command = instruction.substr(0, instruction.find_first_of(" ", 1));
//			for (int ind = 0; ind < (sizeof(jumpInstructions) / sizeof(*jumpInstructions)); ind++)
//			{
//
//				if (toLower(jumpInstructions[ind]) == toLower(command)){
//					cout << command << "\n";
//					node = Node();
//					bool checkElementDuplicacy = false;
//					node.id = id++;
//					jmpaddress = trim(instruction.substr(instruction.find_first_of(" ", 1), instruction.length()));
//					if (ValidateAddress(jmpaddress)){
//
//						for (std::list<string>::iterator jmpListIterator = jumpAddresses.begin(); jmpListIterator != jumpAddresses.end(); ++jmpListIterator)
//						{
//							if (*jmpListIterator == jmpaddress)
//							{
//								checkElementDuplicacy = true;
//								break;
//							}
//						}
//						if (!checkElementDuplicacy)
//						{
//							jumpAddresses.push_back(jmpaddress);
//						}
//						address = it->address;
//						node.childAddress.push_back(jmpaddress);
//						//cout << jmpaddress << "\n";
//						++it;
//						//adding next instructions address as a child's address
//						node.childAddress.push_back(it->address);
//						//cout << it->address << "\n";
//						--it;
//					}
//					else{
//						//Might be because of jump table
//					}
//					node.lastAddress = it->address;
//					lastBlockAddress.push_back(it->address);
//					nodes.push_back(node);
//					break;
//				}
//			}
//
//			for (std::list<string>::iterator jmpListIterator = jumpAddresses.begin(); jmpListIterator != jumpAddresses.end(); ++jmpListIterator)
//			{
//				string test = *jmpListIterator;
//				if (ConvertHexToInt(it->address) == ConvertHexToInt(*jmpListIterator))
//				{
//					--it;
//					/*if (!CheckForJumpCommand(it->instruction))
//					{
//
//					lastBlockAddress.push_back(it->address);
//					node = nodes.back();
//					nodes.pop_back();
//					node.lastAddress = it->address;
//					nodes.push_back(node);
//
//					}*/
//					node = Node();
//					node.id = id++;
//					node.lastAddress = it->address;
//					++it;
//					if (CheckForJumpCommand(it->instruction))
//					{
//						node.childAddress.push_back(it->address);
//					}
//					nodes.push_back(node);
//				}
//			}
//
//		}
//		//adding node at the end of the assembly code
//		if (statements.size() == (cnt))
//		{
//			node = nodes.back();
//
//			if (node.lastAddress == "")
//			{
//				nodes.pop_back();
//				node.lastAddress == it->address;
//			}
//			else
//			{
//				node = Node();
//				node.id = id++;
//				node.lastAddress = it->address;
//				nodes.push_back(node);
//			}
//			//Node node;
//
//			lastBlockAddress.push_back(it->address);
//		}
//
//	}
//
//	std::list<Node>::iterator n = nodes.end();
//	do{
//		--n;
//		cout << n->id << ":" << n->lastAddress << "\n";
//	} while (n != nodes.begin());
//	//for (std::list<Node>::iterator n = nodes.end(); n != nodes.begin(); --n)
//	//{
//	//	//cout<<*it<<"\n";
//	//	cout << n->lastAddress << "\n";
//	//}
//	cout << nodes.size();
//	return 0;
//}
//
